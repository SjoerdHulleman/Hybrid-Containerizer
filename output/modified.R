# ----- Libraries needed for auto-generated code ----- #
library(jsonlite)
library(httr)
library(readr)

# ----- End of libraries ----- ### ----setup, include=FALSE-----------------------------------------------------
options(width = 120)
require(plot3D)
palette("Dark2")


## ----fig.width=8, fig.height=6------------------------------------------------
load(file = "../input_data/Spatio_temporal_settings.rda")
load(file = "../input_data/WKd_Ems.rda")
load(file = "../input_data/Irrad_Ems.rda")
load(file = "../input_data/WAlpha_Ems.rda")
load(file = "../input_data/WEopt_Ems.rda")
load(file = "../input_data/WPs_Ems.rda")
load(file = "../input_data/WHeight_Ems.rda")
load(file = "../input_data/Sediment_Ems.rda")
load(file = "../input_data/BAlpha_Ems.rda")
load(file = "../input_data/BEopt_Ems.rda")
load(file = "../input_data/BPs_Ems.rda")


## -----------------------------------------------------------------------------
require(Rcpp)
sourceCpp("intPP2D.cpp")  # compiles the C++ code and loads the functions


## -----------------------------------------------------------------------------
# Pelagic primary production, assuming mixed water column 
system.time(
#   ppPel <- intPP_mixed(Bat_xyv$depth, 
#                  as.matrix(WKd_Ems    [, -1]), 
#                  as.matrix(Irrad_Ems  [, -1]), 
#                  as.matrix(WAlpha_Ems [, -1]), 
#                  as.matrix(WEopt_Ems  [, -1]), 
#                  as.matrix(WPs_Ems    [, -1]), 
#                  as.matrix(WHeight_Ems[, -1]))
# ----- THIS CODE IS AUTO-GENERATED BY MULTICONTAINERIZER ----- #
# Convert each param to CSV format
csv_zmax <- capture.output(write.csv(as.vector(Bat_xyv$depth), quote=FALSE, row.names=FALSE, col.names=FALSE))
csv_kd <- capture.output(write.csv(as.matrix(as.matrix(WKd_Ems[,-1])), quote=FALSE, row.names=FALSE, col.names=FALSE))
csv_par <- capture.output(write.csv(as.matrix(as.matrix(Irrad_Ems[,-1])), quote=FALSE, row.names=FALSE, col.names=FALSE))
csv_alfa <- capture.output(write.csv(as.matrix(as.matrix(WAlpha_Ems[,-1])), quote=FALSE, row.names=FALSE, col.names=FALSE))
csv_eopt <- capture.output(write.csv(as.matrix(as.matrix(WEopt_Ems[,-1])), quote=FALSE, row.names=FALSE, col.names=FALSE))
csv_pmax <- capture.output(write.csv(as.matrix(as.matrix(WPs_Ems[,-1])), quote=FALSE, row.names=FALSE, col.names=FALSE))
csv_height <- capture.output(write.csv(as.matrix(as.matrix(WHeight_Ems[,-1])), quote=FALSE, row.names=FALSE, col.names=FALSE))

# Prepare a list for JSON conversion
list_ppPel <- list(
	zmax = I(paste(csv_zmax)),
	kd = I(paste(csv_kd)),
	par = I(paste(csv_par)),
	alfa = I(paste(csv_alfa)),
	eopt = I(paste(csv_eopt)),
	pmax = I(paste(csv_pmax)),
	height = I(paste(csv_height))
)
# Convert to JSON format
json_ppPel <- toJSON(list_ppPel, auto_unbox=TRUE)
# URL dependent on configuration
url_ppPel <- "http://localhost:8080/intPP_mixed"

# Call the correct API endpoint for this function and process the result
response_ppPel <- POST(
	url_ppPel,
	body = json_ppPel,
	encode = "raw",
	add_headers("Content-Type" = "application/json")
)

content_ppPel <- content(response_ppPel)

# Capture the results in the original variable, and convert into correct format
ppPel <- as.matrix(content_ppPel)
# ---- END OF AUTO-GENERATED CODE ----- #
)

# radiation at the bottom   
system.time(
#   Rad <- rad_bot(Bat_xyv$depth, 
#                  as.matrix(WKd_Ems     [, -1]), 
#                  as.matrix(Irrad_Ems  [, -1]), 
#                  as.matrix(WHeight_Ems[, -1]))
# ----- THIS CODE IS AUTO-GENERATED BY MULTICONTAINERIZER ----- #
# Convert each param to CSV format
csv_zmax <- capture.output(write.csv(as.vector(Bat_xyv$depth), quote=FALSE, row.names=FALSE, col.names=FALSE))
csv_kd <- capture.output(write.csv(as.matrix(as.matrix(WKd_Ems[,-1])), quote=FALSE, row.names=FALSE, col.names=FALSE))
csv_par <- capture.output(write.csv(as.matrix(as.matrix(Irrad_Ems[,-1])), quote=FALSE, row.names=FALSE, col.names=FALSE))
csv_height <- capture.output(write.csv(as.matrix(as.matrix(WHeight_Ems[,-1])), quote=FALSE, row.names=FALSE, col.names=FALSE))

# Prepare a list for JSON conversion
list_Rad <- list(
	zmax = I(paste(csv_zmax)),
	kd = I(paste(csv_kd)),
	par = I(paste(csv_par)),
	height = I(paste(csv_height))
)
# Convert to JSON format
json_Rad <- toJSON(list_Rad, auto_unbox=TRUE)
# URL dependent on configuration
url_Rad <- "http://localhost:8080/rad_bot"

# Call the correct API endpoint for this function and process the result
response_Rad <- POST(
	url_Rad,
	body = json_Rad,
	encode = "raw",
	add_headers("Content-Type" = "application/json")
)

content_Rad <- content(response_Rad)

# Capture the results in the original variable, and convert into correct format
Rad <- as.matrix(content_Rad)
# ---- END OF AUTO-GENERATED CODE ----- #
)

zn <- 0.002  # depth of chlorophyll layer

# Benthic primary production, 
# exponentially declining chlorophyll concentration, a function of silt fraction
system.time(
#   ppBen <- intPP_exp(as.vector(rep(zn, times = nrow(Bat_xyv))), 
#                     as.vector(Sediment_Ems$Kd), 
#                     as.vector(Sediment_Ems$silt/100),
#                     as.matrix(Rad), 
#                     as.matrix(BAlpha_Ems      [, -1]), 
#                     as.matrix(BEopt_Ems       [, -1]), 
#                     as.matrix(BPs_Ems         [, -1]))
# ----- THIS CODE IS AUTO-GENERATED BY MULTICONTAINERIZER ----- #
# Convert each param to CSV format
csv_zmax <- capture.output(write.csv(as.vector(as.vector(rep(zn,times=nrow(Bat_xyv)))), quote=FALSE, row.names=FALSE, col.names=FALSE))
csv_kd <- capture.output(write.csv(as.vector(as.vector(Sediment_Ems$Kd)), quote=FALSE, row.names=FALSE, col.names=FALSE))
csv_pMud <- capture.output(write.csv(as.vector(as.vector(Sediment_Ems$silt/100)), quote=FALSE, row.names=FALSE, col.names=FALSE))
csv_par <- capture.output(write.csv(as.matrix(as.matrix(Rad)), quote=FALSE, row.names=FALSE, col.names=FALSE))
csv_alfa <- capture.output(write.csv(as.matrix(as.matrix(BAlpha_Ems[,-1])), quote=FALSE, row.names=FALSE, col.names=FALSE))
csv_eopt <- capture.output(write.csv(as.matrix(as.matrix(BEopt_Ems[,-1])), quote=FALSE, row.names=FALSE, col.names=FALSE))
csv_pmax <- capture.output(write.csv(as.matrix(as.matrix(BPs_Ems[,-1])), quote=FALSE, row.names=FALSE, col.names=FALSE))

# Prepare a list for JSON conversion
list_ppBen <- list(
	zmax = I(paste(csv_zmax)),
	kd = I(paste(csv_kd)),
	pMud = I(paste(csv_pMud)),
	par = I(paste(csv_par)),
	alfa = I(paste(csv_alfa)),
	eopt = I(paste(csv_eopt)),
	pmax = I(paste(csv_pmax))
)
# Convert to JSON format
json_ppBen <- toJSON(list_ppBen, auto_unbox=TRUE)
# URL dependent on configuration
url_ppBen <- "http://localhost:8080/intPP_exp"

# Call the correct API endpoint for this function and process the result
response_ppBen <- POST(
	url_ppBen,
	body = json_ppBen,
	encode = "raw",
	add_headers("Content-Type" = "application/json")
)

content_ppBen <- content(response_ppBen)

# Capture the results in the original variable, and convert into correct format
ppBen <- as.matrix(content_ppBen)
# ---- END OF AUTO-GENERATED CODE ----- #
)



## -----------------------------------------------------------------------------
Pelagic_t <- apply(ppPel, MARGIN = 1, FUN = mean)
Benthic_t <- apply(ppBen, MARGIN = 1, FUN = mean)

Pelagic_xy <- data.frame(Bat_xyv, # longitude, latitude, depth
                         ppPel = apply(ppPel, MARGIN = 2, FUN = mean))
Benthic_xy <- data.frame(Bat_xyv, 
                         ppBen = apply(ppBen, MARGIN = 2, FUN = mean))
Rad_bottom <- data.frame(Bat_xyv, rad = colMeans(Rad))


## -----------------------------------------------------------------------------
# save(file = "../output_data/Pelagic_t.rda", Pelagic_t)
# save(file = "../output_data/Benthic_t.rda", Benthic_t)
# save(file = "../output_data/Pelagic_xy.rda", Pelagic_xy)
# save(file = "../output_data/Benthic_xy.rda", Benthic_xy)


## ----fig.width=10, fig.height=6-----------------------------------------------
par(mfrow=c(2,3))
with(Pelagic_xy, 
   points2D(longitude, latitude, colvar=depth, 
         main = "water depth", clab= "m",
         asp=1.8, pch=".", cex=4))

with(Pelagic_xy, 
   points2D(longitude, latitude, colvar=ppPel, 
         main = "Pelagic Photosynthesis", clab="mgC/m2/h",
         asp=1.8, pch=".", cex=4))

with(Benthic_xy, 
   points2D(longitude, latitude, colvar=ppBen, 
         main = "Benthic Photosynthesis", clab="mgC/m2/h", 
         asp=1.8, pch=".", cex=4))

with(Rad_bottom, 
   points2D(longitude, latitude, colvar=rad, 
         main = "Radiation at bottom", clab="uE/m2/s",
         asp=1.8, pch=".", cex=4))

with(Sediment_Ems, 
   points2D(longitude, latitude, colvar=Kd, 
         main = "Sediment extinction", clab="/m",
         asp=1.8, pch=".", cex=4))


